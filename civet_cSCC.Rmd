---
title: "CIVET in cSCC"
output: html_document
---

```{r}
library(tidyverse)
library(Seurat)
```

## bpdcn_TCR

```{r}
source("./supervised_selection_function_twogroup.R")
```

### Read in allel frequency information

```{r}
## zcat cellSNP.base.vcf.gz | grep -v '^#' | awk '{print $2$4">"$5}' > cellSNP.variants.tsv
# Define paths to input files for better readability and maintenance
#base_path <- "/home/linxy29/data/maester/maester_paper/bpdcn712/maester/mquad_pipeline/cellSNP/"
base_path <- "/home/linxy29/data/maester/maester_paper/bpdcn712/maester/bpdcn712_assemble_trimmed_aligned_mt_addtag_cellSNP0/"
ad_mtx_path <- file.path(base_path, "cellSNP.tag.AD.mtx")
dp_mtx_path <- file.path(base_path, "cellSNP.tag.DP.mtx")
features_path <- file.path(base_path, "cellSNP.variants.tsv")
cells_path <- file.path(base_path, "cellSNP.samples.tsv")

# Function to read matrix with error checking
read_mtx_safe <- function(mtx, features, cells, feature.column = 1) {
  if (!file.exists(mtx) || !file.exists(features) || !file.exists(cells)) {
    stop("One or more input files do not exist.")
  }
  
  # Assuming ReadMtx is a predefined function or part of a package not shown here
  ReadMtx(mtx = mtx, features = features, cells = cells, feature.column = feature.column)
}

# Read allele depth (AD) and total depth (DP) matrices
AD_mtx <- read_mtx_safe(ad_mtx_path, features_path, cells_path)
DP_mtx <- read_mtx_safe(dp_mtx_path, features_path, cells_path)

# Calculate allele frequencies, handling division by zero and NA values
af_mtx <- AD_mtx / DP_mtx
af_mtx[is.na(af_mtx)] <- 0  # Replace NA values resulting from division by zero with 0

# Output dimensions of matrices for verification
cat("Dimensions of AD_mtx:", dim(AD_mtx), "\n")
cat("Dimensions of DP_mtx:", dim(DP_mtx), "\n")
cat("Dimensions of af_mtx:", dim(af_mtx), "\n")

# Display a subset of the allele frequency matrix
af_mtx[1:10, 1:10]
```

### Read in TCR information

```{r}
bpdcn_TCR = read_csv("/home/linxy29/data/maester/maester_paper/bpdcn712/bpdcn_clone.csv")
```


### Apply DCATS algorithm

3326 cells have TCR information. 

```{r}
## subset cells with clone information
cell_wClone = bpdcn_TCR %>% 
  mutate(barcode = str_remove(barcode, "-1")) %>% 
  filter(!is.na(TRB_CDR3)) %>% 
  filter(!is.na(MT_clone))
## subset cells in AD and DP
common_barcode = intersect(cell_wClone$barcode, colnames(AD_mtx))
subset_AD = AD_mtx[,common_barcode]
subset_DP = DP_mtx[,common_barcode]
subset_cell_wClone = cell_wClone %>% 
  filter(barcode %in% common_barcode)
subset_AD[1:5, 1:5]
subset_cell_wClone %>% head()
dim(subset_AD)
dim(subset_DP)
dim(subset_cell_wClone)
```

```{r}
sample_DP = subset_DP[3800:3900, 2800:2900]
sample_AD = subset_AD[3800:3900, 2800:2900]
sample_clone_mat = subset_cell_wClone[2800:2900,] %>% 
  select(barcode, TRB_CDR3)
colnames(sample_clone_mat) = c("cellID", "cell_label")
save(sample_AD, sample_DP, sample_clone_mat, file = "sample_multi_AD_DP_clone_mat.RData")
```